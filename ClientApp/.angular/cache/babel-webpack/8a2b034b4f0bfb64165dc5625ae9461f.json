{"ast":null,"code":"// There're 2 types of Angular applications:\n// 1) zone-full (by default)\n// 2) zone-less\n// The developer can avoid importing the `zone.js` package and tells Angular that\n// he is responsible for running the change detection by himself. This is done by\n// \"nooping\" the zone through `CompilerOptions` when bootstrapping the root module.\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nvar isNgZoneEnabled = typeof Zone !== 'undefined' && !!Zone.current;\n/**\n * The function that does the same job as `NgZone.runOutsideAngular`.\n */\n\nexport function runOutsideAngular(callback) {\n  // The `Zone.root.run` basically will run the `callback` in the most parent zone.\n  // Any asynchronous API used inside the `callback` won't catch Angular's zone\n  // since `Zone.current` will reference `Zone.root`.\n  // The Angular's zone is forked from the `Zone.root`. In this case, `zone.js` won't\n  // trigger change detection, and `ApplicationRef.tick()` will not be run.\n  // Caretaker note: we're using `Zone.root` except `NgZone.runOutsideAngular` since this\n  // will require injecting the `NgZone` facade. That will create a breaking change for\n  // projects already using the `@sentry/angular`.\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return isNgZoneEnabled ? Zone.root.run(callback) : callback();\n}","map":{"version":3,"sources":["D:/Studies/Vega/ClientApp/node_modules/@sentry/angular/esm/zone.js"],"names":["isNgZoneEnabled","Zone","current","runOutsideAngular","callback","root","run"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,eAAe,GAAG,OAAOC,IAAP,KAAgB,WAAhB,IAA+B,CAAC,CAACA,IAAI,CAACC,OAA5D;AACA;AACA;AACA;;AACA,OAAO,SAASC,iBAAT,CAA2BC,QAA3B,EAAqC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAOJ,eAAe,GAAGC,IAAI,CAACI,IAAL,CAAUC,GAAV,CAAcF,QAAd,CAAH,GAA6BA,QAAQ,EAA3D;AACH","sourcesContent":["// There're 2 types of Angular applications:\n// 1) zone-full (by default)\n// 2) zone-less\n// The developer can avoid importing the `zone.js` package and tells Angular that\n// he is responsible for running the change detection by himself. This is done by\n// \"nooping\" the zone through `CompilerOptions` when bootstrapping the root module.\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nvar isNgZoneEnabled = typeof Zone !== 'undefined' && !!Zone.current;\n/**\n * The function that does the same job as `NgZone.runOutsideAngular`.\n */\nexport function runOutsideAngular(callback) {\n    // The `Zone.root.run` basically will run the `callback` in the most parent zone.\n    // Any asynchronous API used inside the `callback` won't catch Angular's zone\n    // since `Zone.current` will reference `Zone.root`.\n    // The Angular's zone is forked from the `Zone.root`. In this case, `zone.js` won't\n    // trigger change detection, and `ApplicationRef.tick()` will not be run.\n    // Caretaker note: we're using `Zone.root` except `NgZone.runOutsideAngular` since this\n    // will require injecting the `NgZone` facade. That will create a breaking change for\n    // projects already using the `@sentry/angular`.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    return isNgZoneEnabled ? Zone.root.run(callback) : callback();\n}\n"]},"metadata":{},"sourceType":"module"}